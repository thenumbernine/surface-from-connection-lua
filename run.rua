#! /usr/bin/env rua
local ig = require 'imgui'
local gl = require 'gl'
local matrix = require 'matrix'
local matrix_ffi = require 'matrix.ffi'
local symmath = require 'symmath'
local ffi = require 'ffi'
local vec3f = require 'vec-ffi.vec3f'
local vec3d = require 'vec-ffi.vec3d'
local GLSceneObject = require 'gl.sceneobject'
local gnuplot = require 'gnuplot'

require 'ext.cmdline'.validate{
	help = {
		validate = function(...)
			return require 'ext.cmdline'.showHelpAndQuit(...)
		end,
	},
	geom = true,
	size = true,
	integrationMethod = true,
	calcConnFromMetric = true,
	integrateEWithPP = true,
	calcPPFromConn = true,
	quit = true,
}

--[[ debugging floats ...
local origprint = print
local print = [...] do
	local dtmp = ffi.new'double[1]'
	for i=1,select('#', ...) do
		local x = select(i, ...)
		if i > 1 then io.write'\t' end
		if type(x) == 'number' then
			io.write(x)
			dtmp[0] = x
			io.write('[0x', ('%x'):format(ffi.cast('uint64_t*', dtmp)[0]), ']')
		else
			io.write(tostring(x))
		end
	end
	print()
end
--]]

--[[
local CLEnv = require 'cl.obj.env'
--]]

local int_fe = [t, y, dy_dt, dt]
	(y + dy_dt(t, y) * dt, t + dt)

local int_rk4 = [t, y, dy_dt, dt] do
	local k1 = dy_dt(t, y)
	local k2 = dy_dt(t + .5 * dt, y + .5 * dt * k1)
	local k3 = dy_dt(t + .5 * dt, y + .5 * dt * k2)
	local k4 = dy_dt(t + dt, y + dt * k3)
	return y + (k1 + 2 * k2 + 2 * k3 + k4) * dt / 6, t + dt
end

matrix.isfinite = [:] do
	for i in self:iter() do
		if not math.isfinite(self[i]) then return false end
	end
	return true
end


--local surfaceBuildOrder = 'first'
local surfaceBuildOrder = 'last'
--local surfaceBuildOrder = 'random'
--local surfaceBuildOrder = 'middle'


-- used for providing initial values for the metric
-- and verifying accuracy of numerical calculations
local Geometry = class()

Geometry.init = [:, app] do
	local n = #self.coords
	self.app = app
	self.xmin = self.xmin and matrix(self.xmin) or matrix{n}:lambda([] -1)
	self.xmax = self.xmax and matrix(self.xmax) or matrix{n}:lambda([] 1)
	self.startCoord = matrix(self.startCoord)

	if self.X0 then	-- class provided
		self.X0 = matrix(self.X0)
	elseif self.exactChart then
		self.X0 = self:exactChart(self.startCoord:unpack())
	else
		self.X0 = matrix{n}:zeros()
	end

	if self.e0 then
		self.e0 = matrix(self.e0)
	elseif self.exactBasis then
		self.e0 = self:exactBasis(self.startCoord:unpack())
	else
		self.e0 = matrix{n,n}:eye()
	end

	self.coordVars = table.map(self.coords, [name] do
		local var = symmath.var(name)
		for _,p in ipairs(require 'symmath.tensor.symbols'.greekSymbolsAndNames) do
			local k,v = next(p)
			if var.name == v then
				var:nameForExporter('Lua', k)
			end
		end
		return var
	end)

	if self.createMetric then
		local chart = symmath.Tensor.Chart{coords=self.coordVars}
		local n = #self.coords
		local g = self:createMetric()
		local gU = symmath.Tensor('^ab', table.unpack( (symmath.Matrix.inverse(g)) ))
		local dg = symmath.Tensor('_abc', table.unpack(g'_ab,c'()))
		local ConnL = symmath.Tensor('_abc', table.unpack( ((dg'_abc' + dg'_acb' - dg'_bca')/2)() ))
		local Conn = symmath.Tensor('^a_bc', table.unpack( (gU'^ad' * ConnL'_dbc')() ))
		self.calc = {
			g = self:compileTensor(g),
			Conn = self:compileTensor(Conn),
		}
	end
end

Geometry.testExact = [:] do
	local app = self.app

	local x,y,z

	if app.size[1] == 1 then
		x = matrix{1}:lambda([i] app.xs[1][1][1])
	else
		x = matrix{app.size[1]-3}:lambda([i] app.xs[i+1][1][1])
	end

	if app.size[2] == 1 then
		y = matrix{1}:lambda([j] app.xs[1][1][2])
	else
		y = matrix{app.size[2]-3}:lambda([j] app.xs[1][j+1][2])
	end

	local zrange = app.size - 3
	zrange[1] = math.max(zrange[1], 1)
	zrange[2] = math.max(zrange[2], 1)

	for relindex=0,1 do
		local relativeError = relindex == 1
		for _,info in ipairs{
			-- position integrated vs exact
			{
				name = 'pos',
				title = 'X',
				has = [] self.exactChart,
				calcz = [] do
					return zrange:lambda([i,j] do
						local exact = self:exactChart(app.xs[i+1][j+1]:unpack())
						local err = (exact - app.Xs[i+1][j+1]):normSq()
						if relativeError then
							err = math.sqrt(err / exact:normSq())
						else
							err = math.sqrt(err / zrange:size():prod())
						end
						return err
					end)
				end,
			},
			-- basis integrated/propagated vs exact
			{
				name = 'basis',
				title = 'e_a^b',
				has = [] self.exactBasis,
				calcz = [] do
					return zrange:lambda([i,j] do
						local exact = self:exactBasis(app.xs[i+1][j+1]:unpack())
						local err = (exact - app.es[i+1][j+1]):normSq()
						if relativeError then
							err = math.sqrt(err / exact:normSq())
						else
							err = math.sqrt(err / zrange:size():prod())
						end
						return err
					end)
				end,
			},
			-- connections ... numerical-finite-difference-of-metric vs exact ...
			-- only needed when the connection is calculated numerically from the metric and is not provided explicitly.
			{
				name = 'conn',	-- filename
				title = 'Γ^a_b_c',	-- gnuplot title
				has = [] self.create_conns and app.calcConnFromMetric,
				calcz = [] do
					local exactConns = self:create_conns()	-- TODO rename this to 'exactConns' or something to be like pos and basis exact?
					return zrange:lambda([i,j] do
						local exact = exactConns[i+1][j+1]
						--local exact = self.calc.Conn(self.app.xs[i+1][j+1])
						local err = (exact - app.conns[i+1][j+1]):normSq()
						if relativeError then
							err = math.sqrt(err / exact:normSq())
						else
							err = math.sqrt(err / zrange:size():prod())
						end
						return err
					end)
				end
			},
		} do
			if info.has() then
				z = info.calcz()
				gnuplot{
					output = info.name..' numeric vs analytic'..(relativeError and ' relative' or '')..'.png',
					style = 'data lines',
					xlabel = self.coords and self.coords[1] or 'x^1',
					ylabel = self.coords and self.coords[2] or 'x^2',
					--log = 'z',
					griddata = {x = x, y = y, z},
					{splot=true, using='1:2:3', title = info.title..' |analytic - numeric|'},
				}
				print('max '..info.title..' |analytic - numeric|'..(relativeError and ' relative' or ''), z:normLInf())
			end
		end
	end
end

Geometry.compileTensor = [:, expr] do
	local size = matrix(expr:dim())
	local fs = size:lambda([...] expr[{...}]:compile(self.coordVars))
	return [x] size:lambda([...] fs[{...}](table.unpack(x)))
end

Geometry.calcX0 = [:] do
	if self.startCoord
	and self.exactChart
	then
		return self:exactChart(table.unpack(self.startCoord))
	end
end
Geometry.calcE0 = [:] do
	if self.startCoord
	and self.exactBasis
	then
		return self:exactBasis(table.unpack(self.startCoord))
	end
end

--[[
what each geometry subclass needs:
* coords, to determine the dimension of the surface
* xmin, xmax
* startCoord (where to start the surface generation at.  this is very important.
* one of the two:
	* create_gs - the geometry provides the metric at grid points
	* createMetric - the geometry provides a function that calculates the metric according to input chart coordinates
	(in either case, if create_conns is defined, it is used to validate the numerical accuracy)
* or if neither is chosen
	* create_conns - to use an identity metric and numerical connections
* ... otherwise these return identity g_ab's and zero Γ^a_bc's.

* also parallelPropagatorInvs for creating the parallel propagators ...

then in gui we need options for:
- propagate by connection via metric finite difference (if available)
- propagate by connection provided (if available)
- propagate by parallel propagator (if available)

--]]


-- 2D geometries


local Cartesian2D = Geometry:subclass()
Cartesian2D.coords = {'x', 'y'}
Cartesian2D.xmin = matrix{-1, -1}
Cartesian2D.xmax = matrix{1, 1}
Cartesian2D.startCoord = {0, 0}
Cartesian2D.create_conns = [:] self.app.size:lambda([...] matrix{2,2,2}:zeros())

local Polar = Geometry:subclass()
Polar.coords = {'r', 'φ'}
-- [[ initialize our basis of e=I at r=1 ...
Polar.xmin = matrix{1, 0}
Polar.xmax = matrix{10, 2 * math.pi}
Polar.startCoord = {1,0}
--]]
--[[ applying a rotation, e=I at r=1 and phi!=0 still produces the same shape.
Polar.xmin = matrix{1, 0}
Polar.xmax = matrix{10, 2 * math.pi}
Polar.startCoord = {1, math.pi/2}
--]]
--[[ ...otherwise the shape gets messed up -- for r=2
Polar.xmin = matrix{1, 0}
Polar.xmax = matrix{10, 2 * math.pi}
Polar.startCoord = {2,0}
--]]
--[[ ...otherwise the shape gets messed up -- for r=1/2 (needs the range readjusted so rmin isn't 1)
Polar.xmin = matrix{.1, 0}
Polar.xmax = matrix{2, 2 * math.pi}
Polar.startCoord = {.5,0}
--]]
-- [[ analytically
Polar.exactChart = [:, r, phi] do
	return matrix{r * math.cos(phi), r * math.sin(phi)}
end
Polar.exactBasis = [:, r, phi] do
	local c = math.cos(phi)
	local s = math.sin(phi)
	return matrix{
		{c, s},				-- e_r
		{r * -s, r * c}     -- e_φ
	}
end
Polar.createMetric = [:] do
	local r, phi= self.coordVars:unpack()
	return symmath.Tensor('_ab', {1, 0}, {0, r^2})
end
--]]
-- [[ purely numerically
-- ... if this and create_gs/createMetric is enabled then this is only used to calculate numerical error of connections
Polar.create_conns = [:]
	self.app.size:lambda([...] do
		local r, phi = self.app.xs[{...}]:unpack()
		-- 1/Γ^φ_φr = 1/Γ^φ_rφ = -Γ^r_φφ = r
		return matrix{
			{
				{0, 0},
				{0, -r},
			},
			{
				{0, 1/r},
				{1/r, 0},
			},
		}
	end)
--]]

-- propagator inverse, i.e. propagator of one-forms, since we are propagating our basis' coefficients in the embedded Cartesian basis, which is a one-form
Polar.parallelPropagatorInvs = {
	-- propagating along r ...
	([dr, r, phi] do
		local rFrom = r
		local rTo = r + dr
		return matrix{
			{1, 0},
			{0, rTo / rFrom}
		}
	end),
	-- propagating along φ ...
	([dphi, r, phi] do
		local cos_dphi = math.cos(dphi)
		local sin_dphi = math.sin(dphi)
		return matrix{
			{cos_dphi, -r * sin_dphi},
			{sin_dphi / r, cos_dphi}
		}
	end),
}

-- The thing about non-holonomic geometry is
-- it needs commutation coefficients as well.
-- Otherwise how does it know how far to integrate the geodesics
-- to get to the next coordinate location?
-- This information is typically stored in the metric of the holonomic coordinate map.
local PolarAnholonomic = Geometry:subclass()
PolarAnholonomic.coords = {'r', 'φ'}
PolarAnholonomic.xmin = matrix{1, 0}
PolarAnholonomic.xmax = matrix{10, 2 * math.pi}
PolarAnholonomic.startCoord = {1,0}
PolarAnholonomic.exactChart = [:, r, phi] do
	return matrix{r * math.cos(phi), r * math.sin(phi)}
end
PolarAnholonomic.exactBasis = [:, r, phi] do
	local c = math.cos(phi)
	local s = math.sin(phi)
	return matrix{
		{c, s},		-- e_r
		{-s, c}		-- e_φ
	}
end
PolarAnholonomic.create_conns = [:]
	self.app.size:lambda([i,j] do
		local r = self.app.xs[i][j][1]
		-- Γ^φ_rφ = -Γ^r_φφ = 1/r
		return matrix{
			{{0, 0}, {0, -1/r}},
			{{0, 1/r}, {0, 0}}
		}
	end)
-- if you can get the lengths holonomic basis' vectors then reconstructing the original shape is much easier
PolarAnholonomic.get_basis_lengths = [:, r, phi] matrix{1, r}
PolarAnholonomic.parallelPropagatorInvs = {
	-- propagating along r ...
	([dr, r, phi] do
		return matrix{
			{1, 0},
			{0, 1}
		}
	end),
	-- propagating along φ ...
	-- ok 2 ways to do this ...
	-- 1) consider exp of the anholonomic connection, then we have to factor in the 1/r
	-- 2) only propagate the *coordinate* index, meaning we have to transform by 'e' before applying exp(conn)
	-- for now I'm doing #1 because I'm lazy ... but #2 is more mathematically correct ... but that requires tracking holonomic vs anholonomic e's ... the 'get_basis_length' is sort of a way between them ...
	([dphi, r, phi] do
		dphi /= r	-- divide by 'r' because see #1 above
		local cos_dphi = math.cos(dphi)
		local sin_dphi = math.sin(dphi)
		return matrix{
			{cos_dphi, -sin_dphi},
			{sin_dphi, cos_dphi}
		}
	end),
}

-- cyl surface can't be reconstructed
-- because it needs extrinsic curvature information
-- it has a connection of zero

-- sphere surface likewise is a 2 dimensional system inside 3 dimensions
-- like cyl surface, it needs extrinsic curvature information to be properly rebuilt
local SphereSurface = Geometry:subclass()
local eps = .01
SphereSurface.coords = {'θ', 'φ'}
SphereSurface.xmin = matrix{eps, eps}
SphereSurface.xmax = matrix{math.pi-eps, 2*math.pi-eps}

SphereSurface.startCoord = {math.pi/2, math.pi}	-- poles along x axis
--SphereSurface.startCoord = {2*eps, math.pi}			-- stretched to infinite becuase of infinite connections
--SphereSurface.startCoord = {math.pi/4, math.pi}
--SphereSurface.startCoord = {math.pi/2, 2*eps}		-- mostly y>0
--SphereSurface.startCoord = {math.pi/2, math.pi*2-2*eps}	-- mostly y<0
SphereSurface.createMetric = [:] do
	local theta, phi = self.coordVars:unpack()
	local r = 1
	return symmath.Tensor('_ab',
		{r^2, 0},
		{0, r^2 * symmath.sin(theta)^2}
	)
end


local TorusSurface = Geometry:subclass()
TorusSurface.coords = {'θ', 'φ'}
TorusSurface.xmin = {-math.pi, -math.pi}
TorusSurface.xmax = {math.pi, math.pi}
TorusSurface.startCoord = {0, 0}
TorusSurface.createMetric = [:] do
	local theta, phi = self.coordVars:unpack()
	local r = 2
	local R = 5
	return symmath.Tensor('_ab',
		{r^2, 0},
		{0, (R + r * symmath.sin(theta))^2}
	)
end

local PoincareDisk2D = Geometry:subclass()
PoincareDisk2D.coords = {'u', 'v'}
PoincareDisk2D.xmin = {-1, -1}
PoincareDisk2D.xmax = {1, 1}
PoincareDisk2D.startCoord = {0, 0}
PoincareDisk2D.createMetric = [:] do
	local u, v = self.coordVars:unpack()
	return symmath.Tensor('_ab',
		{4 / (1 - u^2 - v^2), 0},
		{0, 4 / (1 - u^2 - v^2)}
	)
end


-- hmm, how to incorporate signature into the metric ...
local Minkowski2D = Geometry:subclass()
Minkowski2D.coords = {'t', 'x'}
Minkowski2D.xmin = {-1, -1}
Minkowski2D.xmax = {1, 1}
Minkowski2D.startCoord = {0,0}
Minkowski2D.createMetric = [:]
	symmath.Tensor('_ab',
		{-1, 0},
		{0, 1}
	)


-- here's Schwarzschild in time and in radial
-- it is treating Rs as constant, which means this metric is true for the spacetime *outside* of the massive body
local Schwarzschild1Plus1 = Geometry:subclass()
Schwarzschild1Plus1.coords = {'r', 't'}
Schwarzschild1Plus1.xmin = {-2, -2}
Schwarzschild1Plus1.xmax = {2, 2}
Schwarzschild1Plus1.startCoord = {2, 0}
Schwarzschild1Plus1.createMetric = [:] do
	local r, t = self.coordVars:unpack()
	local mass = .1
	return symmath.Tensor('_ab',
		{1/(1 - 2 * mass / r), 0},
		{0, 1 - 2 * mass / r}
	)
end

-- Schwarzschild in time and radial
-- backwards from traditional order: r, t (so that time can point upwards)
-- except for within and outside of the matter source
-- this is my first metric that is based on numerically specifying g_ab, then computing Γ^a_bc
-- since this doesn't have an extra dimension to anchor it, as the spacetime grows from r+ to r- it gets really twisted
local Schwarzschild1Plus1EOS = Geometry:subclass()
Schwarzschild1Plus1EOS.coords = {'r', 't'}
Schwarzschild1Plus1EOS.xmin = {-2, -2}
Schwarzschild1Plus1EOS.xmax = {2, 2}
Schwarzschild1Plus1EOS.startCoord = {2, 0}
Schwarzschild1Plus1EOS.create_gs = [:]
	self.app.size:lambda([...] do
		local r, t = self.app.xs[{...}]:unpack()
		local mass = .1
		local radius = 1
		local radialFrac = math.max(math.abs(r), radius) / radius
		local massWithinRadius = radialFrac * mass
		return matrix{
			{1/(1 - 2 * massWithinRadius / r), 0},
			{0, 1 - 2 * massWithinRadius / r},
		}
	end)

-- here's one from section 2.5 of the "Covariant Loop Quantum Gravity" book
local LagrangianTotalEnergy = Geometry:subclass()
LagrangianTotalEnergy.coords = {'a', 'b'}
LagrangianTotalEnergy.xmin = {-2, -2}
LagrangianTotalEnergy.xmax = {2, 2}
LagrangianTotalEnergy.startCoord = {0, 0}
LagrangianTotalEnergy.create_gs = [:]
	self.app.size:lambda([...] do
		local a, b = self.app.xs[{...}]:unpack()
		local E = 10
		local r = 2 * E - a^2 - b^2
		return matrix{
			{r, 0},
			{0, r}
		}
	end)


-- 3D geometries


local Cylinder = Geometry:subclass()
Cylinder.coords = {'r', 'φ', 'z'}
Cylinder.xmin = {1, 0, -5}
Cylinder.xmax = {10, 2*math.pi, 5}
Cylinder.startCoord = {1,math.pi,0}
Cylinder.createMetric = [:] do
	local r, phi, z = self.coordVars:unpack()
	return symmath.Tensor('_ab',
		{1, 0, 0},
		{0, r^2, 0},
		{0, 0, 1}
	)
end
Cylinder.exactChart = [:, r, phi, z] do
	return matrix{r * math.cos(phi), r * math.sin(phi), z}
end
Cylinder.exactBasis = [:, r, phi, z] do
	local c = math.cos(phi)
	local s = math.sin(phi)
	return matrix{
		{c, s, 0},		-- e_r
		{-s, c, 0},		-- e_φ
		{0, 0, 1},		-- e_z
	}
end

local Sphere = Geometry:subclass()
local eps = .05	-- the holonomic connection gets singularities (cot theta = inf) at the boundaries
				-- this could be avoided if the metric was evaluated at grid centers instead of vertices.
Sphere.coords = {'r', 'θ', 'φ'}
Sphere.xmin = {1, eps, -math.pi + eps}
Sphere.xmax = {10, math.pi - eps, math.pi - eps}
Sphere.startCoord = {1, math.pi/2, 0}
--Sphere.startCoord = {2, math.pi/2, 0}	-- squashed to an ellipsoid, just like the polar case
--Sphere.startCoord = {1, math.pi/2, math.pi-2*eps}	-- changing phi_0 doesn't affect it at all though
--Sphere.startCoord = {2, math.pi/2, math.pi-2*eps}	-- ... though it does a tiny bit (makes some waves in the coordinate system) if r_0 is not 1
Sphere.createMetric = [:] do
	local r, theta, phi = self.coordVars:unpack()
	return symmath.Tensor('_ab',
		{1,0,0},
		{0, r^2, 0},
		{0, 0, r^2 * symmath.sin(theta)^2}
	)
end
Sphere.exactChart = [:, r, theta, phi] do
	local ct = math.cos(theta)
	local st = math.sin(theta)
	local cp = math.cos(phi)
	local sp = math.sin(phi)
	return matrix{r * cp * st, r * sp * st, r * ct}
end
Sphere.exactBasis = [:, r, theta, phi] do
	local ct = math.cos(theta)
	local st = math.sin(theta)
	local cp = math.cos(phi)
	local sp = math.sin(phi)
	return matrix{
		{cp * st, sp * st, ct},					-- e_r
		{r * cp * ct, r * sp * ct, r * -st},	-- e_θ
		{r * -sp, r * cp, 0},					-- e_φ
	}
end

-- TODO I'm betting x0 or e0 is off.  btw there's no way to customize e0(x0) ...
local Torus = Geometry:subclass()
Torus.coords = {'r', 'θ', 'φ'}
Torus.xmin = {1, -math.pi, -math.pi}
Torus.xmax = {2, math.pi, math.pi}
Torus.startCoord = {1, -math.pi, -math.pi}
Torus.createMetric = [:] do
	local r, theta, phi = self.coordVars:unpack()
	local R = 5
	return symmath.Tensor('_ab',
		{1, 0, 0},
		{0, r^2, 0},
		{0, 0, (R + r * symmath.sin(theta))^2}	-- does sin(theta) work as well?
	)
end


local PoincareDisk3D = Geometry:subclass()
PoincareDisk3D.coords = {'u', 'v', 'w'}
PoincareDisk3D.xmin = {-1, -1, -1}
PoincareDisk3D.xmax = {1, 1, 1}
PoincareDisk3D.startCoord = {0, 0, 0}
PoincareDisk3D.createMetric = [:] do
	local u, v, w = self.coordVars:unpack()
	return symmath.Tensor('_ab',
		{4 / (1 - u^2 - v^2 - w^2), 0, 0},
		{0, 4 / (1 - u^2 - v^2 - w^2), 0},
		{0, 0, 4 / (1 - u^2 - v^2 - w^2)}
	)
end


-- Schwarzschild in time and radial
-- backwards from traditional order: r, t (so that time can point upwards)
-- except for within and outside of the matter source
-- this is my first metric that is based on numerically specifying g_ab, then computing Γ^a_bc
-- since this doesn't have an extra dimension to anchor it, as the spacetime grows from r+ to r- it gets really twisted
local Schwarzschild2Plus1EOS = Geometry:subclass()
Schwarzschild2Plus1EOS.coords = {'t', 'x', 'y'}
Schwarzschild2Plus1EOS.xmin = {-2, -2, -2}
Schwarzschild2Plus1EOS.xmax = {2, 2, 2}
--Schwarzschild2Plus1EOS.startCoord = {0, 2, 2}
Schwarzschild2Plus1EOS.startCoord = {0, 0, 0}
Schwarzschild2Plus1EOS.create_gs = [:]
	self.app.size:lambda([...] do
		local t, x, y = self.app.xs[{...}]:unpack()
		local mass = .05
		local radius = 1
		local r = math.sqrt(x*x + y*y)
		local radialFrac = math.max(math.abs(r), radius) / radius
		local massWithinRadius = radialFrac * mass
		return matrix{
			{1 - 2 * massWithinRadius / r, 0, 0},
			{0, 1/(1 - 2 * massWithinRadius / r), 0},
			{0, 0, 1/(1 - 2 * massWithinRadius / r)},
		}
	end)


local SchwarzschildSphere2Plus1EOS = Geometry:subclass()
SchwarzschildSphere2Plus1EOS.coords = {'t', 'r', 'φ'}
SchwarzschildSphere2Plus1EOS.xmin = {-2, .1, -math.pi}
SchwarzschildSphere2Plus1EOS.xmax = {2, 2, math.pi}
SchwarzschildSphere2Plus1EOS.startCoord = {0, 1, 0}
SchwarzschildSphere2Plus1EOS.create_gs = [:]
	self.app.size:lambda([...] do
		local t, r, phi = self.app.xs[{...}]:unpack()
		local mass = .05
		local radius = 1
		local radialFrac = math.max(r, radius) / radius
		local massWithinRadius = radialFrac * mass
		return matrix{
			{1 - 2 * massWithinRadius / r, 0, 0},
			{0, 1/(1 - 2 * massWithinRadius / r), 0},
			{0, 0, r*r},
		}
	end)



-- here's a connection coefficient that gives rise to the stress-energy of a uniform electric field
-- it's based on an analytical connection, but I haven't made a metric for it just yet
local UniformElectricFieldNumericIn2Plus1D = Geometry:subclass()
UniformElectricFieldNumericIn2Plus1D.coords = {'t', 'x', 'y'}		-- ut oh, now we introduce metric signatures ...
UniformElectricFieldNumericIn2Plus1D.xmin = {-1, -1, -1}
UniformElectricFieldNumericIn2Plus1D.xmax = {1, 1, 1}
UniformElectricFieldNumericIn2Plus1D.startCoord = {0, 0, 0}
UniformElectricFieldNumericIn2Plus1D.create_conns = [:] do
	local E_over_sqrt_2 = 1
	return self.app.size:lambda([...]
		matrix{
			{
				{0,E_over_sqrt_2,0},
				{E_over_sqrt_2,0,0},
				{0,0,0},
			},
			{
				{-E_over_sqrt_2,0,0},
				{0,0,0},
				{0,0,E_over_sqrt_2},
			},
			{
				{0,0,0},
				{0,0,0},
				{0,0,0},
			},
		}
	)
end


-- here's a connection coefficient that gives rise to the stress-energy of a uniform electric field
-- it's based on an analytical connection, but I haven't made a metric for it just yet
local UniformElectricFieldNumeric = Geometry:subclass()
UniformElectricFieldNumeric.coords = {'t', 'x', 'y', 'z'}		-- ut oh, now we introduce metric signatures ...
UniformElectricFieldNumeric.xmin = {-1, -1, -1}
UniformElectricFieldNumeric.xmax = {1, 1, 1}
UniformElectricFieldNumeric.startCoord = {0, 0, 0}
UniformElectricFieldNumeric.create_conns = [:] do
	local E_over_sqrt_2 = 1
	return self.app.size:lambda([...]
		matrix{
			{
				{0,E_over_sqrt_2,0,0},
				{E_over_sqrt_2,0,0,0},
				{0,0,0,0},
				{0,0,0,0},
			},
			{
				{-E_over_sqrt_2,0,0,0},
				{0,0,0,0},
				{0,0,E_over_sqrt_2,0},
				{0,0,0,E_over_sqrt_2},
			},
			{
				{0,0,0,0},
				{0,0,0,0},
				{0,0,0,0},
				{0,0,0,0},
			},
		}
	)
end

-- Here's connections that give rise to the stress-energy for the magnetic field
--  around an infinite wire with no net charge.
-- Still no analytical metric for this either.
-- I got it from my file at "symmath/tests/electrovacuum/infinite wire no charge.lua"
-- notice it is 4D, so I need to start thinking of how to handle that.
local InfiniteWireMagneticFieldNumeric = Geometry:subclass()
InfiniteWireMagneticFieldNumeric.coords = {'t', 'r', 'φ', 'z'}
InfiniteWireMagneticFieldNumeric.xmin = {-1, -1, -math.pi, -1}
InfiniteWireMagneticFieldNumeric.xmax = {1, 1, math.pi, 1}
InfiniteWireMagneticFieldNumeric.startCoord = {0, 0, 0, 0}
InfiniteWireMagneticFieldNumeric.create_conns = [:] do
	local I = 1
	return self.app.size:lambda([...] do
		local t, r, phi, z = self.app.xs[{...}]:unpack()
		return matrix{
			{
				{0,0,2*I,0},
				{0,0,0,0},
				{2*I,0,0,0},
				{0,0,0,0},
			},
			{
				{0,0,0,0},
				{0,0,0,0},
				{0,0,0,0},
				{0,0,0,0},
			},
			{
				{2*I/r^2,0,0,0},
				{0,2*I/r^2,0,0},
				{0,0,0,0},
				{0,0,0,2*I/r^2},
			},
			{
				{0,0,0,0},
				{0,0,0,0},
				{0,0,0,0},
				{0,0,0,0},
			},
		}
	end)
end


local App = require 'imguiapp.withorbit'()
App.title = 'reconstruct surface from geodesics'
App.viewDist = 10

App.initGL = [:] do
	App.super.initGL(self)
	gl.glEnable(gl.GL_DEPTH_TEST)

	self.controlsOpened = true
	self.geomID = 1

	self.lineVtxs = ffi.new'vec3f_t[2]'
	self.lineObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec3 vertex;
uniform mat4 mvProjMat;
void main() {
	gl_Position = mvProjMat * vec4(vertex, 1.);
}
]],
			fragmentCode = [[
out vec4 fragColor;
uniform vec3 color;
void main() {
	fragColor = vec4(color, 1.);
}
]],
		},
		vertexes = {
			data = ffi.cast('float*', self.lineVtxs),
			size = ffi.sizeof'vec3f_t' * 2,
			dim = 3,
			count = 2,
		},
		geometry = {
			mode = gl.GL_LINES,
		},
	}

	self:buildSurface(cmdline.geom or 'Polar')
end

local geomClassesForName = table{
	-- 2D
	{Cartesian2D = Cartesian2D},
	{Polar = Polar},
	{PolarAnholonomic = PolarAnholonomic},
	{SphereSurface = SphereSurface},
	{TorusSurface = TorusSurface},
--	{PoincareDisk2D = PoincareDisk2D},	-- crashing
	{Minkowski2D = Minkowski2D},
	{Schwarzschild1Plus1 = Schwarzschild1Plus1},
	{Schwarzschild1Plus1EOS = Schwarzschild1Plus1EOS},
	{LagrangianTotalEnergy = LagrangianTotalEnergy},
	-- 3D
	{Cylinder = Cylinder},
	{Sphere = Sphere},
	{Torus = Torus},
--	{PoincareDisk3D = PoincareDisk3D},	-- crashing
	{UniformElectricFieldNumericIn2Plus1D = UniformElectricFieldNumericIn2Plus1D },
	{Schwarzschild2Plus1EOS = Schwarzschild2Plus1EOS},
	{SchwarzschildSphere2Plus1EOS = SchwarzschildSphere2Plus1EOS},
	-- 4D
--	{UniformElectricFieldNumeric = UniformElectricFieldNumeric},	-- crashing
	{InfiniteWireMagneticFieldNumeric = InfiniteWireMagneticFieldNumeric},
}
local geomClassNames = geomClassesForName:map([kv] ((next(kv))) )

local GridFilter = class()
GridFilter.init = [:, grid, xmin, xmax, size] do
	self.grid = assert(grid)
	self.xmin = assert(xmin):clone()
	self.xmax = assert(xmax):clone()
	self.size = assert(size):clone()
	local n = #self.size
	self.zero = self.grid[matrix{n}:lambda([] 1)]:map([] 0)
end

local NearestGridFilter = GridFilter:subclass()
NearestGridFilter.__call = [:, app, x] do
	local is = (x - self.xmin):ediv(self.xmax - self.xmin):emul(self.size - 3) + 2.5
	is = is:map([x,j] math.clamp(math.floor(x), 1, self.size[j]))
	return assert(self.grid[is]):clone()
end

local LinearGridFilter = GridFilter:subclass()
LinearGridFilter.__call = [:, app, x] do
--print()
--print('x', x, 'xmin', self.xmin, 'xmax', self.xmax)
	local n = #self.size

	-- vertex-centered with [2,2] at xmin, and [size-1] at xmax
	-- this should match the dx xmin xmax calculations in :rebuildGeometry()
	local is = (x - self.xmin):ediv(self.xmax - self.xmin):emul(self.size - 3) + 2

	local fs = is - is:map([x] math.floor(x))
	for j=1,n do
		is[j] = math.clamp(math.floor(is[j]), 1, self.size[j])
		if is[j] == self.size[j] then fs[j] = 0 end	-- is this necessary?
	end

--for j=1,n do assert.le(0, fs[j]) assert.le(fs[j], 1) end
--print('is', is, 'fs', fs)

	-- n-linear interpolation
	local sum = self.zero:clone()
	for cornerBits = 0,(1<<n)-1 do
		local cis = is:clone()
		local coeff = 1
		for j=1,n do
			local has = (cornerBits >> (j-1)) & 1
			cis[j] += has
			if has == 0 then
				coeff *= 1 - fs[j]
			else
				coeff *= fs[j]
			end
		end
--print('cornerBits', cornerBits, 'coeff', coeff, 'cis', cis)
		if coeff > 0 then
			sum += self.grid[cis] * coeff
		end
	end
--print('sum', sum)
	return sum
end

local gridFilterMethods = {
	NearestGridFilter,
	LinearGridFilter,
}

App.buildSurface = [:, geomName] do
	assert(geomName)
	local loc, geomClass = geomClassesForName:find(nil, [kv] next(kv) == geomName)
	assert(geomClass, "couldn't find geometry named "..geomName)
	geomClass = assert(select(2, next(geomClass)))
	self.geomID = loc

--[[
	self.env = CLEnv()
--]]

	local geom = geomClass(self)
	self.geom = geom

	-- n = manifold dimension
	local n = #geom.coords

	-- size = lattice size (not necessary correlating with points or lines)
	self.size = cmdline.size
		and matrix(cmdline.size)
		or matrix{n}:lambda([i] (({[2]=16, [3]=16, [4]=8})[n]) )

	-- detail = how many extra steps between lattice points to emit lines ...
	-- ... if I do this then should the metric be interpolated?  or should it be constant? should the filter method be chosen in the GUI?
	--self.detail = matrix{n}:lambda([i] 10)

	self.filterMethods = table{
		'nearest',
		'linear',
	}

	self.basisFilterMethod = 2		-- filter of conn lookup when integrating e's
	self.posFilterMethod = 2	-- filter of e lookup when integrating x's

	self.integrationMethods = table{
		{['F.E.'] = int_fe},
		{RK4 = int_rk4},
	}
	self.integrationMethod = cmdline.integrationMethod or 2

	-- TODO more flags ...
	-- - use provided conn vs finite-difference conn
	-- - use provided p.p. or numerical mat-exp calculated from conn
	-- - integrate e by conn or by P.P.

	-- if the geometry doesn't have 'create_conns' then we must use finite-difference of metric
	-- true = use g_uv for Conn_abc
	-- false = use Conn_abc provided in geom.create_conns
	self.calcConnFromMetric = cmdline.calcConnFromMetric ?? false

	-- true = use P(x+dx,x) * e(x) => e(x+dx)
	-- false = e(x+dx) = integral( conn * e(x+s) ds)
	self.integrateEWithPP = cmdline.integrateEWithPP ?? true

	-- true = use matrix-exp to calc P(x,y) from Conn_abc
	-- false = use P(x,y) provided in geom.parallelPropagatorInvs
	self.calcPPFromConn = cmdline.calcPPFromConn ?? false


--[[
	self.domain = self.env:domain{size=self.size}
--]]

	self.view.ortho = n == 2

	-- reset view every time you change charts
	self.view.pos:set(0,0,self.viewDist)
	self.view.orbit:set(0,0,0)
	self.view.angle:set(0,0,0,1)

--[=[ opencl code
	-- regenerate these to prevent ffi cdef redefs
	self.rank1Type = 'rank1_t'
	self.rank2Type = 'rank2_t'
	local rank1TypeCode = 'typedef real '..self.rank1Type..'['..n..'];'
	local rank2TypeCode = 'typedef real '..self.rank2Type..'['..n..'];'
	local ffi = require 'ffi'
	ffi.cdef(rank1TypeCode)

	local template = require 'template'
	local clnumber = require 'cl.obj.number'

	self.headerCode = table{
		rank1TypeCode,
		template([[
<? for j=0,n-1 do ?>
#define size_<?=j?> <?=size[j+1]?>
#define xmin_<?=j?> <?=clnumber(xmin[j+1])?>
#define xmax_<?=j?> <?=clnumber(xmax[j+1])?>
#define dx_<?=j?> ((xmax_<?=j?> - xmin_<?=j?>) / (real)(size_<?=j?> - 3))
<? end ?>
]], 	{
			n = n,
			clnumber = clnumber,
			size = self.size,
			xmin = geom.xmin,
			xmax = geom.xmax,
		}),
	}:concat'\n'


	self.xsBuf = self.domain:buffer{name='xs', type=self.rank1Type}
	self.domain:kernel{
		header = self.headerCode,
		argsOut = {self.xsBuf},
		body = template([[
<? for j=0,n-1 do
?>	xs[index][<?=j?>] = (i.s<?=j?> - 2) * dx_<?=j?> + xmin_<?=j?>;
<? end
?>]], {n = n}),
	}()

	if geom.createMetric
	or geom.create_gs
	then
		self.gsBuf = self.domain:buffer{name='gs', type=self.rank2Type}
		self.gUsBuf = self.domain:buffer{name='gUs', type=self.rank2Type}
	end
--]=]

	self:rebuildSurface()
end

App.rebuildSurface = [:] do
print()
print('App:rebuildSurface...')
	local n = #self.size
	local geom = self.geom
	local _ = matrix.index

	self.surfaceObj = nil

	--[[ cell centered, including borders
	self.dx = matrix{n}:ones():emul(geom.xmax - geom.xmin):ediv(self.size)
	self.xs = self.size:lambda([...] ((matrix{...} - .5):emul(self.dx) + geom.xmin) )
	--]]
	-- [[ vertex centered, excluding borders, so position 2,2 is at xmin (useful for centering the corner vertex)
	self.dx = matrix{n}:ones():emul(geom.xmax - geom.xmin):ediv(self.size - 3)
--print('self.size', self.size:unpack())
--print('self.dx', self.dx:unpack())
--print('geom.xmin', geom.xmin:unpack())
--print('geom.xmax', geom.xmax:unpack())
	self.xs = self.size:lambda([...] ((matrix{...} - 2):emul(self.dx) + geom.xmin) )
--print('self.xs:norm()', self.xs:norm())

	local integrator = select(2, next(self.integrationMethods[self.integrationMethod]))

	self.conns = nil
	self.Xs = nil
	self.es = nil
	self.getConn = nil
	self.getParallelPropagatorInv = nil


	-- calculate Γ^a_bc := 1/2 inv(g_au) (Δ_c g_ub + Δ_b g_uc - Δ_u g_bc)
	if self.calcConnFromMetric then
		if not (geom.createMetric or geom.create_gs) then
			print('!!! WARNING !!! createMetric / create_gs not provided by this geometry !!!')
			return
		end

		local gs
print('creating metric...')
		if geom.create_gs then
print('getting numerical metric from geom...')
			gs = geom:create_gs()
		elseif geom.calc.g then	-- should be there if createMetric is there ...
print('getting analytical metric from geom...')
			gs = self.size:lambda([...] geom.calc.g(self.xs[{...}]))
			-- TODO might as well compute g^ab analytically too ...
		else
			print('!!! WARNING !!! createMetric found but calc.g missing !!!')
			return
		end

--print('gs:norm()', gs:norm())

		--or self.size:lambda([...] matrix{n,n}:eye() )
print('numerically calculating metric inverse...')
		local gUs = self.size:lambda([...] gs[{...}]:inv())

--print('gUs:norm()', gUs:norm())

print('using finite-difference to calculate metric derivatives...')
		local dgs = self.size:lambda([...] do
			local i = matrix{...}
			-- dg[a][b][c] := d/dx^a g_bc
			local dg = matrix{n}:lambda([a] do
				-- using a constant border
				local ip = i:clone() ip[a] = math.min(ip[a]+1, self.size[a])
				local im = i:clone() im[a] = math.max(im[a]-1, 1)
				-- using a first-order derivative
				return (gs[ip] - gs[im]) / (self.xs[ip][a] - self.xs[im][a])
			end)
			-- reshape dg_abc = g_ab,c
			return matrix{n,n,n}:lambda([a,b,c] dg[c][a][b])
		end)

--print('dgs norm', dgs:norm())

print('creating connections numerically...')
		self.conns = self.size:lambda([...] do
			local i = matrix{...}
			local dg = dgs[i]
			-- TODO this assumes the metric is holonomic ... otherwise TODO we need the commutation coefficients
			local numConnLower = matrix{n,n,n}:lambda([a,b,c] .5 * (dg[a][b][c] + dg[a][c][b] - dg[b][c][a]))
			local gU = gUs[i]
			return gU * numConnLower
		end)

	-- use Γ^a_bc provided
	-- TODO ... future functions shouldn't use self.conns
	-- they should use an access method in geom
	-- and that access method should do filtering
	-- or in the case of analytical, it should give an exact value based on index or chart argument
	else
		if not geom.create_conns then
			print('!!! WARNING !!! create_conns not provided by this geometry !!!')
			return
		end

print('getting conns from geom...')
		self.conns = geom:create_conns()
	end

--print('self.conns:norm()', self.conns:norm())

	-- TODO geom.calc.Conn for analytical connection without any kind of grid filtering
	self.getConn = gridFilterMethods[self.basisFilterMethod](self.conns, geom.xmin, geom.xmax, self.size)
--[[ verify lookup works
	for index in self.size:range() do
print('comparing index', index, 'x', self.xs[index])
		assert.eqeps(self.conns[index]:norm(), self:getConn(self.xs[index]):norm(), 1e-7)
	end
--]]

	-- if we are calculating the connection from discrete derivatives of the metric ...
	local integrateBasis
	if not self.integrateEWithPP then
		-- e = basis matrix ... are rows or cols the basis forms?
		-- x = chart coordinates
		-- k = which dimension we're moving along
		-- ds = amount we're moving along the k'th coordinate
		integrateBasis = [e, x, k, ds] do
			return integrator(0, e, [s, e] do
				x = x:clone()
				x[k] += s
				return self:getConn(x)(_,_,k):T() * e
			end, ds)
		end
	else

		-- use geom.parallelPropagatorInvs for parallel propagators
		if not self.calcPPFromConn then
			if not geom.parallelPropagatorInvs then
				print('!!! WARNING !!! parallelPropagatorInvs not provided by this geometry !!!')
				return
			end
			self.getParallelPropagatorInv = [:, k, ds, x] do
				return geom.parallelPropagatorInvs[k](ds, x:unpack())
			end
		-- numerically calculate parallel-propagator from connection exp
		else
			self.getParallelPropagatorInv = [:, k, ds, x] do
				local connk = self:getConn(x)(_,_,k)
				local x2 = x:clone()
				x2[k] += ds
				local connkMid = self:getConn(x2)(_,_,k)

				-- numerically integrate from connk to connkMid along ds ... using a single trapezoid
				-- maybe TODO could be using the 'integrate' library
				local connkInt = (.5 * ds) * (connk + connkMid)

				-- now we want to calculate P(x,x+dxk) = exp(-int(conn_k from x to x+dxk))
				-- so first we want to integrate from connk to connkMid along ds ...
				-- next we want to exponent the integral
				-- ... but for propagating one-forms, i.e. basis components in embedded space, we want to multiply by P^-T
				local A = matrix_ffi(connkInt:T(), 'complex double')
				local expA = A:expm()
				expA = matrix_ffi(expA, 'double'):toLuaMatrix()
print()
print('x', x, 'k', k, 'ds', ds)
print'A'
print(A)
print'expA'
print(expA)
				return expA
			end
		end

		integrateBasis = [e, x, k, ds] do
			local propInv_k = self:getParallelPropagatorInv(k, ds, x)
			return matrix{n}:lambda([i]
				propInv_k:T() * e(_,i)
			):T()
		end
	-- TODO - parallel-propagate based on matrix-exponent of connection from finite-difference of metric (and numerical inverse)
	end

	-- embedded space position
	self.Xs = self.size:lambda([...] matrix{n}:zeros())

	-- rows of es = components of the basis vectors in the embedded Cartesian space
	self.es = self.size:lambda([...] matrix{n,n}:zeros())

	local index0
	do
		local xInit = matrix(assert(geom.startCoord))
--print('x0:norm()', xInit:norm(), xInit)
		index0 = ((xInit - geom.xmin):ediv(geom.xmax - geom.xmin):emul(self.size-3) + 2.5):map(math.floor)
--print('index0', index0)
		for j=1,n do
			if self.size[j] > 1 then
				-- make sure we can finite-difference ... TODO this somewhere else, in the integration loop?
				index0[j] = math.clamp(index0[j], 2, self.size[j]-1)
			else
				index0[j] = 1
			end
			-- TODO reset the start coord in the GUI if it has to be clamped
		end

		self.Xs[index0] = geom.X0:clone()	-- geom:calcX0()	-- default zeroes
--print('geom.X0:norm()', geom.X0:norm())

		self.es[index0] = geom.e0:clone()	-- geom:calcE0()	-- default ident
--print('geom.e0:norm()', geom.e0:norm())
	end

--print(i, self.es[i]:unpack())
	local withinEdge = [index,size] do
		for i=1,n do
			if index[i] <= 1 or index[i] >= size[i] then return false end
		end
		return true
	end

print'building surface...'
	-- now to reconstruct the es based on the conns ...
	-- [=[ flood fill
	local todo = table{index0}
	local sofar = {[tostring(index)] = true}
	while #todo > 0 do
		local index = todo:remove(1)
		local x = self.xs[index]

		-- [[
		local conn = self:getConn(x)
		--]]
		--[[
		local conn = self.conns[index]
		--]]

--if not conn then error("failed to get conn at index "..tostring(index)) end
		-- for each direction ...
		for k=1,n do
			-- TODO why not store the coordinate index first?
			local connk = conn(_,_,k)

			for dir=-1,1,2 do
				local nextIndex = index:clone()
				nextIndex[k] += dir
				-- skip the edges
				if withinEdge(nextIndex, self.size)
				and not sofar[tostring(nextIndex)]
				then
					local xNext = self.xs[nextIndex]

					-- cheating to get around anholonomic coordinate systems
					-- technically I should be using commutation coefficients or something
					-- or maybe this isn't cheating since we should be integrating by coordinate distances, which were normalized out in anholonomic basis ...
					-- 'len' should be the transform from local-minkowski to the coordinate basis
					local len = 1
					if geom.get_basis_lengths then
						-- how far in coordinate-space we need to integrate
						local lens = geom:get_basis_lengths(x:unpack())
						len = len * lens[k]
					end

					-- derivative along coordinate
					local ds = dir * self.dx[k] * len

					local XOrig = self.Xs[index]
					local eOrig = self.es[index]

					local e, X
					if not self.integrateEWithPP then
						--[[ integrate e then X ...
						-- for polar holonomic, X error <= 0.38936524475501, e error <= 0.38171956061742
						e = integrateBasis(eOrig, x, k, ds, nextIndex, dir, connk)
						X = integrator(0, XOrig, [s, X] do
							return math.mix(
								eOrig[k],
								e[k],
								self.posFilterMethod == 2 and s / ds or 0
							)
						end, ds)
						--]]
						-- [=[ integrate e and X at the same time for better accuracy ...
						-- for polar holonomic, X error <= 0.22228580818733, e error <= 0.22455744144822
						local XEOrig = matrix{
							XOrig,
							eOrig:unpack()
						}
						--dXE of the X is e[k]
						--dXE of the e is conn[_,_,k] ... or it's the negative transpose of the conn ...
						local XE = integrator(0, XEOrig, [s, XE] do
							local emid = integrateBasis(eOrig, x, k, s)
							local dX = emid[k]
							local xmid = math.mix(x, xNext, ds == 0 and 0 or s / ds)
							local connmid = self:getConn(xmid)(_,_,k)
							local dE = connmid:T() * emid
							local XEmid = matrix{
								dX,
								dE:unpack()
							}
							return XEmid
						end, ds)
						X = table.remove(XE, 1)
						e = XE
						--]=]
					else
						-- propagate e, use mid-propagated e's to integrate X
						-- for polar holonomic, X error <= 0.00037882000703206, e error <= 5.1265983257016e-15
						e = integrateBasis(eOrig, x, k, ds)
						X = integrator(0, XOrig, [s, X] do
							local emid = integrateBasis(eOrig, x, k, s)
							return emid[k]
						end, ds)
					end

					--[[ matrix-exponent to calculate parallel-propagator numerically (instead of numerically integrating the connection)
					-- TODO eigen-decompose and then exponent the eigenvalues ...
					do
						-- if d/ds e = conn e then ...
						-- then we can solve this as a linear dynamic system!
						-- even though this assumes conn is constant (which it's not)
						-- for constant connections (like integrating polar coordinates around phi) this is no problem
						-- de/e = conn ds
						-- e = C exp(conn s) = C Q exp(λ s) Q^-1
						--
						-- 2D eigenvalues
						-- (a-λ)(d-λ) - bc = 0 <=> λ^2 - (a+d) λ + (ad-bc) = 0 <=> λ = 1/2 ( (a+d) +- sqrt( a^2 + 2ad + d^2 - 4 (ad - bc) ) )
						-- λ = (a+d)/2 +- sqrt( ((a-d)/2)^2 + bc ) )
						--print('conn '..geom.coords[k]..':\n'..connk)
						local a,b = connk[1]:unpack()
						local c,d = connk[2]:unpack()
						local asym = (a - d) / 2
						local discr = asym^2 + b * c

						local de

						-- [a b]
						-- [c a]
						if a == d and b ~= 0 and c ~= 0 then
							if b * c >= 0 then
								local l1, l2 = a + sd, a - sd
								local evR = matrix{{1, 1}, {math.sqrt(c/b), -math.sqrt(c/b)}}
								local evL = matrix{{1, math.sqrt(b/c)}, {1, -math.sqrt(b/c)}} / 2
								de = [ds] do
									return evR * matrix{
										{math.exp(ds * l1), 0},
										{0, math.exp(ds * l2)}
									} * evL
								end
							else
								-- b c < = means either b or c < 0 but not both
								local theta = math.sqrt(-b * c)
								local ratio = math.sqrt(-b / c)
								de = [ds] do
									local costh = math.cos(theta * ds)
									local sinth = math.sin(theta * ds)
									return matrix{
										{costh, -sinth / ratio},
										{sinth / ratio, costh}
									} * math.exp(a * ds)
								end
							end
						-- [a b]
						-- [0 a] for a real and b nonzero
						elseif a == d and b ~= 0 then
							-- TODO solve this without eigen-decomposition
							error("defective matrix "..connk)
						-- [a 0]
						-- [0 d] for a,b any real
						elseif b == 0 and c == 0 then
							local l1, l2 = a, d
							local evR = matrix{{1,0},{0,1}}
							local evL = evR:clone()
							de = [ds] do
								return evR * matrix{
									{math.exp(ds * l1), 0},
									{0, math.exp(ds * l2)}
								} * evL
							end
						-- [a b]
						-- [0 d]
						elseif c == 0 then
							local l1, l2 = a, d
							local evR = matrix{{1, 0}, {b, d-a}}:T()
							local evL = matrix{{1, b/(a-d)}, {0, -1/(a-d)}}
							de = [ds] do
								return evR * matrix{
									{math.exp(ds * l1), 0},
									{0, math.exp(ds * l2)}
								} * evL
							end
						-- [a 0]
						-- [c d]
						elseif b == 0 then
							local l1, l2 = a, d
							local evR = matrix{{a-d, c}, {0, 1}}:T()
							local evL = matrix{{1/(a-d), 0}, {-c/(a-d), 1}}
							de = [ds] do
								return evR * matrix{
									{math.exp(ds * l1), 0},
									{0, math.exp(ds * l2)}
								} * evL
							end
						elseif discr == 0 then	-- means (a-d)^2 = 4*b*c, then we have multiplicity 2
							error"here"
						elseif discr > 0 then
							local complex = require 'complex'
							-- 2D eigenvectors using the smaller eigenvalue
							-- [a-λ, b]    [ a - (a+d)/2 + sqrt( ((a-d)/2)^2 + bc ),    b ]    [ (a-d)/2 + sqrt( ((a-d)/2)^2 + bc ), b ]
							-- [c, d-λ] => [ c,    d - (a+d)/2 + sqrt( ((a-d)/2)^2 + bc ) ] => [ c, (d-a)/2 + sqrt( ((a-d)/2)^2 + bc ) ]
							--
							-- [ (sqrt( ((a-d)/2)^2 + bc ) + (a-d)/2)(sqrt( ((a-d)/2)^2 + bc ) - (a-d)/2), b((d-a)/2 + sqrt( ((a-d)/2)^2 + bc )) ]
							-- [ b c, b((d-a)/2 + sqrt( ((d-a)/2)^2 + bc )) ]
							--
							-- c x + ((d-a)/2 + sqrt( ((a-d)/2)^2 + bc )) y = 0
							-- y = t
							-- x = 1/c ((a-d)/2 - sqrt( ((a-d)/2)^2 + bc )) t
							local avg = (a + d) / 2
							local sd = complex.sqrt(discr)
							local l1, l2 = avg + sd, avg - sd
							local evR = matrix{{asym + sd, asym - sd}, {c, c}}
							local evL = matrix{
								{-1, (asym + sd)/c},
								{1, (-asym + sd)/c},
							} / (2 * sd)
							de = [ds] do
								return evR * matrix{
									{math.exp(ds * l1), 0},
									{0, math.exp(ds * l2)}
								} * evL
							end
						else -- discr < 0	-- complex eigenvectors
							error"here"
						end

						X = int_rk4(0, X, [s] ((e * de(s))(_,k)), ds)
						e = e * de(ds)
					end
					--]]

					--[[ normalize rows
					for k=1,n do
						e[k] = e[k] / e[k]:norm()
					end
					--]]

--[[
print()
print('index='..index)
--print('self.dx='..self.dx)
print('nextIndex='..nextIndex)
print('ds='..ds)
print('x='..x)
print('conn[k]='..connk)
print('XOrig='..XOrig)
print('X='..X)
print('eOrig='..eOrig)
print('e='..e)
--]]

					self.es[nextIndex] = e
--print(nextIndex, self.es[nextIndex]:unpack())
					self.Xs[nextIndex] = X

--print('e2 from '..eOrig(_,2)..' to '..e(_,2)..' changing by '..(eOrig(_,2) - e(_,2)):norm())
--print('|e2| from '..eOrig(_,2):norm()..' to '..e(_,2):norm()..' changing by '..(e(_,2):norm() - eOrig(_,2):norm()))
--print('X from '..XOrig..' to '..X..' changing by '..(X - XOrig):norm())

					if surfaceBuildOrder == 'last' then
						todo:insert(nextIndex)
					elseif surfaceBuildOrder == 'random' then
						todo:insert(math.random(#todo+1), nextIndex)
					elseif surfaceBuildOrder == 'middle' then
						todo:insert(math.floor((#todo+1)/2), nextIndex)
					elseif surfaceBuildOrder == 'first' then
						-- the linear dynamic system method only works right for polar coordinates when we use this order
						todo:insert(1, nextIndex)
					end
					sofar[tostring(nextIndex)] = true
				end
			end
		end
	end
	--]]

	if geom then
print('*** comparing connections from create_gs / create whatever to create_conns ***')
		geom:testExact()
	end
--print('self.Xs:norm()', self.Xs:norm())
--print('self.es:norm()', self.es:norm())

	local com = matrix{n}:lambda([] 0)
	for i in self.size:range() do
		if self.Xs[i]:isfinite() then
			com += self.Xs[i]
		end
	end
	com /= self.size:prod()
	for i=1,n do
		self.view.pos.s[i-1] = -com[i]
		self.view.orbit.s[i-1] = -com[i]
	end
	self.view.pos.z += self.viewDist
	self.view.angle:set(0,0,0,1)

	local vertexes = table()
	local vertex2s = table()
	local colors = table()
-- [[
	local sizeMinusOne = self.size-1
	for indexMinusOne in sizeMinusOne:range() do
		local index = indexMinusOne+1
		for k=1,n do
			if index[k] < sizeMinusOne[k] then
				local nextIndex = index:clone()
				nextIndex[k] += 1

				local color = (index-1):ediv(sizeMinusOne)
				colors:append{color[1] or 0, color[2] or 0, color[3] or .5}
				local vertex2 = self.xs[index]
				vertex2s:append{vertex2[1] or 0, vertex2[2] or 0, vertex2[3] or 0}
				local vertex = self.Xs[index]
				vertexes:append{vertex[1] or 0, vertex[2] or 0, vertex[3] or 0}

				local color = (nextIndex-1):ediv(sizeMinusOne)
				colors:append{color[1] or 0, color[2] or 0, color[3] or .5}
				local vertex2 = self.xs[nextIndex]
				vertex2s:append{vertex2[1] or 0, vertex2[2] or 0, vertex2[3] or 0}
				local vertex = self.Xs[nextIndex]
				vertexes:append{vertex[1] or 0, vertex[2] or 0, vertex[3] or 0}
			end
		end
	end
--]]
--[[ trying to get this to work with size=1
	for index in self.size:range() do
		for k=1,n do
			if self.size[k] > 1
			and index[k] < self.size[k]-1
			then
				local nextIndex = index:clone()
				nextIndex[k] += 1

				local color = (index-1):ediv((self.size-1):map([x] math.max(x, 1) ))
				colors:append{color[1] or 0, color[2] or 0, color[3] or .5}
				local vertex2 = self.xs[index]
				vertex2s:append{vertex2[1] or 0, vertex2[2] or 0, vertex2[3] or 0}
				local vertex = self.Xs[index]
				vertexes:append{vertex[1] or 0, vertex[2] or 0, vertex[3] or 0}

				local color = (nextIndex-1):ediv((self.size-1):map([x] math.max(x, 1) ))
				colors:append{color[1] or 0, color[2] or 0, color[3] or .5}
				local vertex2 = self.xs[nextIndex]
				vertex2s:append{vertex2[1] or 0, vertex2[2] or 0, vertex2[3] or 0}
				local vertex = self.Xs[nextIndex]
				vertexes:append{vertex[1] or 0, vertex[2] or 0, vertex[3] or 0}
			end
		end
	end
--]]

	self.surfaceObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec3 vertex;
in vec3 vertex2;
in vec3 color;
out vec3 colorv;
uniform float t;
uniform mat4 mvProjMat;
void main() {
	colorv = color;
	vec3 pos1 = vertex.xyz;
	vec3 pos2 = vertex2.xyz;
	vec3 pos = mix(pos1, pos2, t);
	gl_Position = mvProjMat * vec4(pos, 1.);
}
]],
			fragmentCode = [[
in vec3 colorv;
out vec4 fragColor;
void main() {
	fragColor = vec4(colorv, 1.);
}
]],
			uniforms = {t = 0},
		},
		geometry = {
			mode = gl.GL_LINES,
		},
		vertexes = {
			data = vertexes,
			count = #vertexes / 3,
			dim = 3,
		},
		attrs = {
			vertex2 = {
				buffer = {
					data = vertex2s,
					count = #vertex2s / 3,
					dim = 3,
				},
			},
			color = {
				buffer = {
					data = colors,
					count = #colors / 3,
					dim = 3,
				},
			},
		},
	}
end

App.drawGrid = [:] do
	local xmin, xmax, ymin, ymax = self.view:getBounds(self.width / self.height)
	xmin += self.view.pos.x
	ymin += self.view.pos.y
	xmax += self.view.pos.x
	ymax += self.view.pos.y

	self.lineObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
	self.lineObj.uniforms.color = {.1, .1, .1}

	local xrange = xmax - xmin
	local xstep = 10^math.floor(math.log(xrange, 10) - .5)
	local xticmin = math.floor(xmin/xstep)
	local xticmax = math.ceil(xmax/xstep)

	for x=xticmin,xticmax do
		self.lineVtxs[0]:set(x*xstep, ymin, 0)
		self.lineVtxs[1]:set(x*xstep, ymax, 0)
		self.lineObj.vertexes:bind():updateData():unbind()
		self.lineObj:draw()
	end

	local yrange = ymax - ymin
	local ystep = 10^math.floor(math.log(yrange, 10) - .5)
	local yticmin = math.floor(ymin/ystep)
	local yticmax = math.ceil(ymax/ystep)
	for y=yticmin,yticmax do
		self.lineVtxs[0]:set(xmin, y*ystep, 0)
		self.lineVtxs[1]:set(xmax, y*ystep, 0)
		self.lineObj.vertexes:bind():updateData():unbind()
		self.lineObj:draw()
	end

	self.lineObj.uniforms.color = {.5, .5, .5}

	self.lineVtxs[0]:set(xmin, 0, 0)
	self.lineVtxs[1]:set(xmax, 0, 0)
	self.lineObj.vertexes:bind():updateData():unbind()
	self.lineObj:draw()

	self.lineVtxs[0]:set(0, ymin, 0)
	self.lineVtxs[1]:set(0, ymax, 0)
	self.lineObj.vertexes:bind():updateData():unbind()
	self.lineObj:draw()
end


local animating = false
local lastTime = 0
local gui = {
	animTime = 0,
}
App.update = [:] do
	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)

	local n = #self.size

	local thisTime = os.clock()
	if animating then
		local deltaTime = (thisTime - lastTime) / math.pi
		gui.animTime = (((gui.animTime + deltaTime) + 1) % 2) - 1
	end
	lastTime = thisTime

	if self.surfaceObj then
		self.surfaceObj.uniforms.t = .5 - .5 * math.cos(math.pi * gui.animTime)
		self.surfaceObj.uniforms.mvProjMat = self.view.mvProjMat.ptr
		self.surfaceObj:draw()
	end

--[[ draw the basis at every point?
		local colors = matrix{
			{1,0,0},
			{0,1,0},
			{0,0,1},
		}

		local scale = .05
		gl.glMatrixMode(gl.GL_MODELVIEW_MATRIX)
		gl.glPushMatrix()
		gl.glTranslatef(0,0,.1 * scale)
		gl.glBegin(gl.GL_LINES)
		for indexMinusOne in sizeMinusOne:range() do
			local index = indexMinusOne+1
			local u = self.Xs[index]
			local e = self.es[index]
			for k=1,n do
				glColor3f(colors[k])
				glVertex(u)
				glVertex(u + scale * e[k])
			end
		end
		gl.glEnd()
		gl.glPopMatrix()
--]]

	if n == 2 then
		self:drawGrid()
	elseif n == 3 then
		-- draw the xyz basis
		-- TODO viewport instead?
		local hudView = require 'glapp.view'{
			angle = self.view.angle,
		}
		local aspectRatio = self.width / self.height
		hudView.pos = hudView.angle:rotate(vec3d(4 * aspectRatio, 4, 5))
		hudView:setup(aspectRatio)

		-- draw basis
		self.lineObj.uniforms.mvProjMat = hudView.mvProjMat.ptr

		for i=1,3 do
			self.lineObj.uniforms.color = {0, 0, 0}
			self.lineObj.uniforms.color[i] = 1

			self.lineVtxs[0]:set(0,0,0)
			self.lineVtxs[1]:set(0,0,0)
			self.lineVtxs[1].s[i-1] = 1
			self.lineObj.vertexes:bind():updateData():unbind()
			self.lineObj:draw()
		end
	end

	App.super.update(self)

	if cmdline.quit then self:requestExit() end
end

App.updateGUI = [:] do
	local geom = self.geom
	local n = #geom.coords
	if ig.luatableBegin('Controls', self, 'controlsOpened') then
		if ig.igButton(animating and 'Stop Animation' or 'Start Animation') then
			animating = not animating
		end

		ig.luatableTooltipSliderFloat('animation coefficient', gui, 'animTime', -1, 1)

		if ig.luatableTooltipCombo('coordinate system', self, 'geomID', geomClassNames) then
			self:buildSurface(geomClassNames[self.geomID])
		end

		for _,field in ipairs{'basisFilterMethod', 'posFilterMethod'} do
			ig.igPushID_Str(field)
			ig.igText(field..':')
			for i,name in ipairs(self.filterMethods) do
				if ig.luatableRadioButton(name, self, field, i) then
					self:rebuildSurface()
				end
			end
			ig.igPopID()
		end

		ig.igText'integration method:'
		ig.igPushID_Str'integration method'
		for i,info in ipairs(self.integrationMethods) do
			local name, func = next(info)
			if ig.luatableRadioButton(name, self, 'integrationMethod', i) then
				self:rebuildSurface()
			end
		end
		ig.igPopID()

		if ig.luatableCheckbox('use finite-difference-metric conn (vs provided)', self, 'calcConnFromMetric') then
			self:rebuildSurface()
		end
		if ig.luatableCheckbox('propagate basis (vs integrate)', self, 'integrateEWithPP') then
			self:rebuildSurface()
		end
		if ig.luatableCheckbox('use matrix-exp-conn propagator (vs provided)', self, 'calcPPFromConn') then
			self:rebuildSurface()
		end

		ig.igText'resolution'
		for j=1,n do
			if ig.luatableTooltipInputInt('size '..j, self.size, j, 0, 0, ig.ImGuiInputTextFlags_EnterReturnsTrue) then
				self:rebuildSurface()
			end
			if j < n then ig.igSameLine() end
		end

		for _,field in ipairs{'xmin', 'xmax', 'startCoord', 'X0'} do
			ig.igText(field == 'startCoord' and 'x0' or field)
			for j=1,n do
				if ig.luatableTooltipInputFloat(field..' '..j, geom[field], j, .01, .1, '%f', ig.ImGuiInputTextFlags_EnterReturnsTrue) then
					if field == 'startCoord' then
						geom.startCoord[j] = math.clamp(geom.startCoord[j], geom.xmin[j], geom.xmax[j])
					end
					self:rebuildSurface()
				end
				if j < n then ig.igSameLine() end
			end
		end

		ig.igText'e0'
		for i=1,n do
			for j=1,n do
				if ig.luatableTooltipInputFloat('e0_'..i..'_'..j, geom.e0[i], j, .01, .1, '%f', ig.ImGuiInputTextFlags_EnterReturnsTrue) then
					self:rebuildSurface()
				end
				if j < n then ig.igSameLine() end
			end
		end
	end
	ig.igEnd()
end

App():run()
